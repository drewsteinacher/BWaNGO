@inject ILabelsRepository LabelsRepository
@inject IJSRuntime JsRuntime
@inject ClipboardService ClipboardService

@page "/labels"
@using BWaNGO.Repositories
@using BWaNGO.Services

<NavigationLock ConfirmExternalNavigation="@CanSaveLabels()"
                OnBeforeInternalNavigation="UnsavedChangesDialog" />

<PageTitle>Labels</PageTitle>

<MudText Typo="Typo.h5">Labels</MudText>
<br/>

<MudText Typo="Typo.body1">Enter custom bingo square labels here, one per line.</MudText>
<MudText Typo="Typo.body1">American Bingo is usually played with 75 numbers, but cards hold 24 each (the center space is free).</MudText>
<MudText Typo="Typo.body1">If you do not enter at least 24 labels, the remaining squares will be filled by sampling.</MudText>

<br/>

<!-- TODO: Style this so that it fills the entire vertical space available -->
<MudTextField T="string"
              Label="@_inputLabel"
              Variant="Variant.Filled"
              Lines="25"
              AutoGrow="false"
              @bind-Value="@_currentRawLabelText"
              Immediate="true"
              FullWidth="true"
              ShrinkLabel="true"
              Adornment="!CanSaveLabels() ? Adornment.End : Adornment.None"
              AdornmentIcon="@_shareIcon"
              AdornmentColor="@_shareColor"
              OnAdornmentClick="ShareLabels"
/>

<MudText Typo="Typo.body1" Color="CanSaveLabels() ? Color.Default : Color.Success">
    @Repositories.LabelsRepository.ParseLabels(_currentRawLabelText).Count Labels @(CanSaveLabels() ? "Unsaved" : "Saved") 
</MudText>

<MudButton Variant="Variant.Outlined"
           Color="Color.Warning"
           Disabled="!CanSaveLabels()"
           OnClick="@ReadLabels">
    Reset
</MudButton>
<MudButton Variant="Variant.Filled"
           Color="Color.Primary"
           Disabled="!CanSaveLabels()"
           OnClick="@SaveLabels">
    Save
</MudButton>

@code {
    private string _currentRawLabelText = string.Empty;
    private string _savedRawLabelText = string.Empty;
    
    private string _shareIcon = Icons.Material.Filled.Share;
    private Color _shareColor = Color.Surface;
    private string _inputLabel = "Labels";
    
    protected override async Task OnInitializedAsync()
    {
        await ReadLabels();
        await base.OnInitializedAsync();
    }
    
    private async Task ReadLabels()
    {
        _currentRawLabelText = await LabelsRepository.GetRaw() ?? string.Empty;
        _savedRawLabelText = _currentRawLabelText;
    }
    
    private Task SaveLabels()
    {
        _savedRawLabelText = _currentRawLabelText;
        return LabelsRepository.SaveAsync(_currentRawLabelText);
    }

    private bool CanSaveLabels()
        => _currentRawLabelText != _savedRawLabelText;

    private async Task UnsavedChangesDialog(LocationChangingContext context)
    {
        if (!CanSaveLabels())
        {
            return;
        }

        var isConfirmed = await JsRuntime.InvokeAsync<bool>("confirm", 
            "You have unsaved changes. Are you sure you want to leave?");

        if (!isConfirmed)
        {
            context.PreventNavigation();
        }
    }

    private async Task ShareLabels(MouseEventArgs obj)
    {
        // TODO: Generate URL with labels as query parameter
        await ClipboardService.WriteTextAsync("CLICKED SHARE LABELS");
        
        (_shareIcon, _shareColor, _inputLabel) = (Icons.Material.Filled.Check, Color.Success, "Labels (URL copied to clipboard!)");
        StateHasChanged();
        
        await Task.Delay(TimeSpan.FromSeconds(2));
        
        (_shareIcon, _shareColor, _inputLabel) = (Icons.Material.Filled.Share, Color.Primary, "Labels");
        StateHasChanged();
    }

}