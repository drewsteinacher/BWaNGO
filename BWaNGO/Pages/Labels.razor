@inject ILabelsService labelsService
@inject IJSRuntime JsRuntime

@page "/labels"
@using BWaNGO.Services

<NavigationLock ConfirmExternalNavigation="@CanSaveLabels()"
                OnBeforeInternalNavigation="UnsavedChangesDialog" />

<PageTitle>Labels</PageTitle>

<MudText Typo="Typo.h2">Labels</MudText>
<br/>

<MudText Typo="Typo.body1">Enter custom bingo square labels here, one per line.</MudText>
<MudText Typo="Typo.body1">American Bingo is usually played with 75 numbers, but cards hold 24 each (the center space is free).</MudText>
<MudText Typo="Typo.body1">If you do not enter at least 24 labels, the remaining squares will be filled by sampling.</MudText>

<br/>

<MudTextField T="string"
              Label="Labels"
              Variant="Variant.Filled"
              Lines="25"
              AutoGrow="false"
              @bind-Value="@_currentRawLabelText"
              Immediate="true"
/>

<MudText Typo="Typo.body1" Color="CanSaveLabels() ? Color.Default : Color.Success">
    @LabelsService.ParseLabels(_currentRawLabelText).Count Labels @(CanSaveLabels() ? "Unsaved" : "Saved") 
</MudText>

<MudButton Variant="Variant.Outlined"
           Color="Color.Warning"
           Disabled="!CanSaveLabels()"
           OnClick="@ReadLabels">
    Reset
</MudButton>
<MudButton Variant="Variant.Filled"
           Color="Color.Primary"
           Disabled="!CanSaveLabels()"
           OnClick="@SaveLabels">
    Save
</MudButton>

@code {
    private string _currentRawLabelText = string.Empty;
    private string _savedRawLabelText = string.Empty;

    protected override async Task OnInitializedAsync()
    {
        await ReadLabels();
        await base.OnInitializedAsync();
    }
    
    private async Task ReadLabels()
    {
        try
        {
            _currentRawLabelText = await labelsService.GetRaw() ?? string.Empty;
            _savedRawLabelText = _currentRawLabelText;
        }
        catch (Exception exception)
        {
            Console.WriteLine("Error retrieving labels from local storage, clearing: " + exception.Message);
            await ClearLabels();
        }
    }
    
    private Task SaveLabels()
    {
        _savedRawLabelText = _currentRawLabelText;
        return labelsService.SaveAsync(_currentRawLabelText);
    }

    private Task ClearLabels()
    {
        _savedRawLabelText = string.Empty;
        return labelsService.SaveAsync(string.Empty);
    }

    private bool CanSaveLabels()
        => _currentRawLabelText != _savedRawLabelText;

    private async Task UnsavedChangesDialog(LocationChangingContext context)
    {
        if (!CanSaveLabels())
        {
            return;
        }

        var isConfirmed = await JsRuntime.InvokeAsync<bool>("confirm", 
            "You have unsaved changes. Are you sure you want to leave?");

        if (!isConfirmed)
        {
            context.PreventNavigation();
        }
    }
}